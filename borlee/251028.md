**닉네임**: borlee

**문제 플랫폼**: leetcode

**문제 이름 또는 번호**: 232. Implement Queue using Stacks

**문제 링크**: https://leetcode.com/problems/implement-queue-using-stacks/

**오늘의 메모(선택)**: 
c 언어로 바꾸기
input -> output 이동 시 순서 반전-> FIFO

**코드(선택)**

<!-- ```python
class MyQueue(object):

    def __init__(self):
        self.input = []
        self.output = []
        

    def push(self, x):
        self.input.append(x)
        

    def pop(self):
        self.peek()
        return self.output.pop()
        

    def peek(self):
        if not self.output:
            while self.input:
                self.output.append(self.input.pop())
        return self.output[-1]
        

    def empty(self):
        return self.input == [] and self.output == []
``` -->


```c
#include <stdbool.h>
#include <stdlib.h>

#define MAX_SIZE 128

typedef struct 
{
    int input[MAX_SIZE];
    int output[MAX_SIZE];
    int top_in;
    int top_out;    
} MyQueue;


MyQueue* myQueueCreate() 
{
    MyQueue *obj = malloc(sizeof(MyQueue));
    if (!obj)
        return NULL;
    obj->top_in = -1;
    obj->top_out = -1;
    return obj;
}

static void stackPush(int *stack, int *top, int x)
{
    if (*top >= MAX_SIZE - 1)
        return ;
    *top = *top + 1;
    stack[*top] = x;
}

static int stackPop(int *stack, int *top)
{
    int value = 0;
    
    if (*top < 0)
        return -1;
    value = stack[*top];
    *top = *top - 1;
    return value;
}

void myQueuePush(MyQueue* obj, int x) 
{
    stackPush(obj->input, &obj->top_in, x);
}

int myQueuePop(MyQueue* obj) 
{
    if (obj->top_out == -1)
    {
        while (obj->top_in != -1)
        {
            int value = stackPop(obj->input, &obj->top_in);
            stackPush(obj->output, &obj->top_out, value);
        }
    }
    return stackPop(obj->output, &obj->top_out);
}

int myQueuePeek(MyQueue* obj) 
{
    if (obj->top_out == -1)
    {
        while (obj->top_in != -1)
        {
            int value = stackPop(obj->input, &obj->top_in);
            stackPush(obj->output, &obj->top_out, value);
        }
    }
    return obj->output[obj->top_out];
}

bool myQueueEmpty(MyQueue* obj) 
{
    return (obj->top_in == -1 && obj->top_out == -1);
}

void myQueueFree(MyQueue* obj) 
{
    if (obj)
        free(obj);
}

/**
 * Your MyQueue struct will be instantiated and called as such:
 * MyQueue* obj = myQueueCreate();
 * myQueuePush(obj, x);
 
 * int param_2 = myQueuePop(obj);
 
 * int param_3 = myQueuePeek(obj);
 
 * bool param_4 = myQueueEmpty(obj);
 
 * myQueueFree(obj);
*/
```