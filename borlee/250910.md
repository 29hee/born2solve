**닉네임**: borlee

**문제 플랫폼**: leetcode

**문제 이름 또는 번호**: 39. Combination Sum

**문제 링크**: https://leetcode.com/problems/combination-sum/description/

**오늘의 메모(선택)**: 순열과 다르게 조합의 합계산은 경우의 수를 미리 예측할 수가 없다. 그래서 동적할당하기 전에 메모리 크기를 우선 넉넉하게 잡아서 했더니 메모리 결과적으로는 좋지 않게 나왔다. (런타임은 괜찮음)
c 코드로 바꾸기 - 구조체/프로토타입 없이, calloc 활용
테스트 코드 candidates = [4,8,11,10,9,3,12,7,6] target = 25
TODO: realloc 사용해보기


**코드(선택)**:

```c
#include <stdlib.h>
#include <stdio.h>

static void	save_combination(int **result, int *returnColumnSizes,
		int *returnSize, int *path, int path_size)
{
	int	*comb;
	int	i;

	comb = (int *)calloc(path_size, sizeof(int));
	if (!comb)
		return ;
	i = 0;
	while (i < path_size)
	{
		comb[i] = path[i];
		i++;
	}
	result[*returnSize] = comb;
	returnColumnSizes[*returnSize] = path_size;
	(*returnSize)++;
}

static void	backtrack(int *candidates, int candidatesSize,
		int start, int *path, int path_size, int remain,
		int **result, int *returnColumnSizes, int *returnSize)
{
	int	i;

	if (remain == 0)
	{
		save_combination(result, returnColumnSizes,
			returnSize, path, path_size);
		return ;
	}
	if (remain < 0)
		return ;
	i = start;
	while (i < candidatesSize)
	{
		path[path_size] = candidates[i];
		backtrack(candidates, candidatesSize, i, path, path_size + 1,
			remain - candidates[i], result, returnColumnSizes, returnSize);
		i++;
	}
}

int	**combinationSum(int *candidates, int candidatesSize,
		int target, int *returnSize, int **returnColumnSizes)
{
	int	max_combinations;
	int	**result;
	int	*col_sizes;
	int	*path;

	max_combinations = 10000; 
	result = (int **)calloc(max_combinations, sizeof(int *));
	col_sizes = (int *)calloc(max_combinations, sizeof(int));
	path = (int *)calloc(target, sizeof(int));
	if (!result || !col_sizes || !path)
		return (NULL);
	*returnSize = 0;
	backtrack(candidates, candidatesSize, 0, path, 0, target,
		result, col_sizes, returnSize);
	free(path);
	*returnColumnSizes = col_sizes;
	return (result);
}

// int	main(void)
// {
// 	int		candidates[] = {4, 8, 11, 10, 9, 3, 12, 7, 6};
// 	int		candidatesSize = sizeof(candidates) / sizeof(candidates[0]);
// 	int		target = 25;
// 	int		returnSize;
// 	int		*returnColumnSizes;
// 	int		**result;

// 	result = combinationSum(candidates, candidatesSize,
// 			target, &returnSize, &returnColumnSizes);
// 	if (!result)
// 		return (1);

// 	printf("=== Results ===\n");
// 	for (int i = 0; i < returnSize; i++)
// 	{
// 		printf("[");
// 		for (int j = 0; j < returnColumnSizes[i]; j++)
// 		{
// 			printf("%d", result[i][j]);
// 			if (j < returnColumnSizes[i] - 1)
// 				printf(", ");
// 		}
// 		printf("]\n");
// 	}

// 	for (int i = 0; i < returnSize; i++)
// 		free(result[i]);
// 	free(result);
// 	free(returnColumnSizes);
// 	return (0);
// }
```


