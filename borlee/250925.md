**닉네임**: borlee

**문제 플랫폼**: leetcode

**문제 이름 또는 번호**: 771. Jewels and stones

**문제 링크**: https://leetcode.com/problems/jewels-and-stones/submissions/1780276522/

**오늘의 메모(선택)**: 
 c언어에는 해시 테이블이 없어서 직접 구현해야 한다. 배열을 사용해서 해시 테이블처럼 동작하도록 구현했다.
 int stone_counts[ALPHABET_SIZE] = {0}; // 각 문자의 빈도를 세기 위한 배열 *** gpt 의견이다.

**코드(선택)**:

/*해시 테이블을 이용한 풀이.*/
```python
class Solution:
    def numJewelsInStones(self, jewels: str, stones: str) -> int:
        stone_counts: Dict[str, int] = {}

        for stone in stones:
            if stone not in stone_counts:
                stone_counts[stone] = 1
            else:
                stone_counts[stone] += 1

        jewel_count: int = 0
        for jewel in jewels:
            if jewel in stone_counts:
                jewel_count += stone_counts[jewel]

        return jewel_count
```
```c
#define ALPHABET_SIZE 52 // 소문자 대문자 알파벳의 갯수

bool is_lower(char c)
{
    return c >= 'a' && c <= 'z';
}

bool is_upper(char c)
{
    return c >= 'A' && c <= 'Z';
}

int numJewelsInStones(char* jewels, char* stones) 
{
    int stone_counts[ALPHABET_SIZE] = {0}; // 각 문자의 빈도를 세기 위한 배열 ***
    int jewel_count = 0;

    for (int i = 0; stones[i]; i++)
    {
        if (is_lower(stones[i]))
            stone_counts[stones[i] - 'a']++;
        else if (is_upper(stones[i]))
            stone_counts[stones[i] - 'A' + 26]++;
    }    
    for (int i = 0; jewels[i]; i++)
    {
        if (is_lower(jewels[i]))
            jewel_count += stone_counts[jewels[i] - 'a'];
        else if (is_upper(jewels[i]))
            jewel_count += stone_counts[jewels[i] - 'A' + 26];
    }
    return jewel_count;
}
```