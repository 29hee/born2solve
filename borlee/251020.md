**닉네임**: borlee

**문제 플랫폼**: leetcode

**문제 이름 또는 번호**: 51.N-Queens

**문제 링크**: https://leetcode.com/problems/n-queens

**오늘의 메모(선택)**: 
프로그래머스 n-queens문제와 다르게 경우의 수를 세는 것이 아니라
모든 해의 배치를 문자열 배열로 반환해야 한다.
- 그래서 make_board를 만들어야 함
- 이전의 is_safe 거의 그대로 사용. backtrack는 반환타입을 void로 바꾸고
 조금 수정했다.
- 삼항 연산 써보기(막상 써보니 쓸만하다)
- 1 <= n <= 9  해의 갯수는 다음과 같다.
n   1   2   3   4   5   6   7    8   9    
A   1	0	0	2	10	4	40	92	352

**코드(선택)**

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX_SOLUTIONS 400

typedef struct  s_result
{
    char ***boards;
    int count;
}               t_result;

static int ft_abs(int a)
{
    return (a < 0) ? -a: a;
}

static bool is_safe(int *queen_cols, int current_row, int col)
{
    for (int prev_row = 0; prev_row < current_row; prev_row++)
    {
        if(queen_cols[prev_row] == col)
            return false;
        if(ft_abs(queen_cols[prev_row] - col) == current_row - prev_row)
            return false;
    }
    return true;
}

char **make_board(int *queen_cols, int n)
{
    char **board = malloc(sizeof(char *) * n);
    for (int i = 0; i < n; i++)
    {
        board[i] = malloc(sizeof(char) * (n + 1));
        for (int j = 0; j < n; j++)
            board[i][j] = (queen_cols[i] == j) ? 'Q' : '.';
        board[i][n] = '\0';
    }
    return board;
}

void backtrack(int *queen_cols, int current_row, int n, t_result *result)
{
    if (current_row == n)
    {
        result->boards[result->count] = make_board(queen_cols, n);
        result->count++;
        return ;
    }
    for (int col = 0; col < n; col++)
    {
        if (is_safe(queen_cols, current_row, col))
        {
            queen_cols[current_row] = col;
            backtrack(queen_cols, current_row + 1, n, result);
        }
    }
}

/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
char*** solveNQueens(int n, int* returnSize, int** returnColumnSizes) 
{
    t_result result;
    result.count = 0;
    result.boards = malloc(sizeof(char **) * MAX_SOLUTIONS);
    if (!result.boards)
        return NULL;

    int *cols = malloc(sizeof(int) * n);
    if(!cols)
    {
        free(result.boards);
        return NULL;
    }
    backtrack(cols, 0, n, &result);
    // 반환 코드 맞추기
    *returnSize = result.count;
    *returnColumnSizes = malloc(sizeof(int) * result.count);
    if(!*returnColumnSizes)
    {
        free(cols);
        free(result.boards);
        return NULL;
    }
    for (int i = 0; i < result.count; i++)
        (*returnColumnSizes)[i] = n; // 조심
    free(cols);
    return result.boards;
}
```