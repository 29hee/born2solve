**닉네임**: borlee

**문제 플랫폼**: 리트코드

**문제 이름 또는 번호**: 1971. Find if Path Exists in Graph

**문제 링크**: https://leetcode.com/problems/find-if-path-exists-in-graph/description/

**오늘의 메모(선택)**: 
파이썬 코드 c 로 바꾸기
-- 실수로 16일 파일에 17일 덮어쓰기를 했다..

**코드(선택)**

```c
static void init_parent_rank(int *parent, int *rank, int count)
{
    int i = 0;
    while (i < count)
    {
        parent[i] = i;
        rank[i] = 0;
        i++;
    }
}

static int find_root(int *parent, int x)
{
    while (parent[x] != x)
    {
        parent[x] = parent[parent[x]];
        x = parent[x];
    }
    return x;
}

// 랭크 기반으로
static void merge_set(int *parent, int *rank, int a, int b)
{
    int ra = find_root(parent, a);
    int rb = find_root(parent, b);

    if (ra == rb)
        return ;
    if (rank[ra] < rank[rb])
        parent[ra] = rb;
    else if (rank[ra] > rank[rb])
        parent[rb] = ra;
    else
    {
        parent[rb] = ra;
        rank[ra] += 1; 
    }
}

bool validPath(int n, int** edges, int edgesSize, int* edgesColSize, int source, int destination) {
    int *parent;
    int *rank;
    int i = 0;;
    bool result;

    if (source == destination)
        return true;
    parent = malloc(sizeof(int) * n);
    rank = malloc(sizeof(int) * n);
    if (!parent || !rank)
    {
        free(parent);
        free(rank);
        return false;
    }
    init_parent_rank(parent, rank, n);
    
    // 모든 간선에 대해 union
    while (i < edgesSize)
    {
        int u = edges[i][0];
        int v = edges[i][1];
        merge_set(parent, rank, u, v);
        i++;
    }
    result = (find_root(parent, source) == find_root(parent, destination));
    free(parent);
    free(rank);
    return result;
}
```