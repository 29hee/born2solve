**닉네임**: taebkim

**문제 플랫폼**: 백준

**문제 이름 또는 번호**: 21610 / 마법사 상어와 비바라기

**문제 링크**: https://www.acmicpc.net/problem/21610

**오늘의 메모(선택)**: 

**코드(선택)**:

```c++
#include <algorithm>
#include <cmath>
#include <iomanip>
#include <iostream>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <stack>
#include <stdexcept>
#include <string>
#include <unordered_set>
#include <utility>
#include <vector>

#define TAEBKIM                                                                \
    std::ios::sync_with_stdio(false);                                          \
    std::cin.tie(NULL);                                                        \
    std::cout.tie(NULL);

;

using namespace std;

#define MAX 55
int N, M;
int MAP[MAX][MAX];
bool cloud_map[MAX][MAX];
vector<pair<int, int>> cloud;
vector<pair<int, int>> cmd;
long long answer = 0;

int dx[] = {0, 0, -1, -1, -1, 0, 1, 1, 1};
int dy[] = {0, -1, -1, 0, 1, 1, 1, 0, -1};

void input() {
    cin >> N >> M;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            cin >> MAP[i][j];
        }
    }
    for (int i = 0; i < M; i++) {
        int a, b;
        cin >> a >> b;
        cmd.push_back({a, b});
    }
}

void init_cloud() {
    cloud.push_back({N - 1, 0});
    cloud.push_back({N - 1, 1});
    cloud.push_back({N - 2, 0});
    cloud.push_back({N - 2, 1});

    cloud_map[N - 1][0] = true;
    cloud_map[N - 1][1] = true;
    cloud_map[N - 2][0] = true;
    cloud_map[N - 2][1] = true;
}

int make_range(int x) {
    if (x < 0)
        return x + N;
    if (x >= N)
        return x - N;
    return x;
}

void move_cloud(int idx) {
    int Dir = cmd[idx].first;
    int Cnt = cmd[idx].second;

    int move_cnt = Cnt % N;

    memset(cloud_map, false, sizeof(cloud_map));

    for (auto &p : cloud) {
        int x = p.first;
        int y = p.second;

        int nx = x + dx[Dir] * move_cnt;
        int ny = y + dy[Dir] * move_cnt;

        nx = (nx % N + N) % N;
        ny = (ny % N + N) % N;

        p.first = nx;
        p.second = ny;
        cloud_map[nx][ny] = true;
    }
}

void make_rain() {
    for (const auto &p : cloud) {
        MAP[p.first][p.second]++;
    }
}

void water_bug() {
    int d_diag[] = {2, 4, 6, 8};

    for (const auto &p : cloud) {
        int x = p.first;
        int y = p.second;
        int Cnt = 0;

        for (int j : d_diag) {
            int nx = x + dx[j];
            int ny = y + dy[j];

            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {
                if (MAP[nx][ny] >= 1) {
                    Cnt++;
                }
            }
        }
        MAP[x][y] += Cnt;
    }
}

void delete_cloud() { cloud.clear(); }

void make_cloud() {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (cloud_map[i][j] == true)
                continue;

            if (MAP[i][j] >= 2) {
                cloud.push_back({i, j});

                MAP[i][j] -= 2;
            }
        }
    }

    memset(cloud_map, false, sizeof(cloud_map));
    for (const auto &p : cloud) {
        cloud_map[p.first][p.second] = true;
    }
}

void find_answer() {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            answer += MAP[i][j];
        }
    }
}

void solution() {
    init_cloud();
    for (int i = 0; i < M; i++) {
        move_cloud(i);
        make_rain();
        water_bug();
        delete_cloud();
        make_cloud();
    }
    find_answer();
    cout << answer << '\n';
}

void solve() {
    input();
    solution();
}

int main() {
    TAEBKIM;

    solve();

    return 0;
}
```