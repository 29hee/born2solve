닉네임: eonoh

문제 플랫폼: 백준

문제 이름 또는 번호: 17471 / 게리맨더링

문제 링크: https://www.acmicpc.net/problem/17471

오늘의 메모(선택): 이전에는 조합을 찾을 때 dfs 를 사용하였습니다. 이번에는 비트마스킹을 이용하여 조합을 만드는 코드를 작성해보았습니다. 또한 이전에는 코드가 너무 길었습니다. 비슷한 기능을 하는 함수들을 하나로 표현하여 코드 길이를 줄였습니다.

코드(선택): cpp

```cpp
#include <iostream>
#include <vector>
#include <limits.h>
#include <cstring>
#include <queue>
using namespace std;

int population[11];
long minimum, diff;
bool aGroup[11], visited[11];
vector<vector<int> > area(11);

void init() {
	memset(population, 0, sizeof(population));
	minimum = INT_MAX;
	diff = 0;
	area.assign(11, vector<int>());
}

int isConnected(bool bit, int idx) {
	queue<int> q;
	int cnt = 0;

	memset(visited, false, sizeof(visited));
	q.push(idx);
	cnt++;
	visited[idx] = true;
	while (!q.empty()) {
		int front = q.front();
		q.pop();
		for (int x : area[front]) {
			if (!visited[x] && aGroup[x] == bit) {
				q.push(x);
				visited[x] = true;
				cnt++;
			}
		}
	}
	return cnt;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	int n, t, u;

	cin >> n;
	init();
	for (int i = 1; i <= n; i++) {
		cin >> population[i];
	}
	for (int i = 1; i <= n; i++) {
		cin >> t;
		for (int j = 0; j < t; j++) {
			cin >> u;
			area[i].push_back(u);
		}
	}
	for (int i = 1; i <= (1 << (n - 1)); i++) {
		memset(aGroup, false, sizeof(aGroup));
		int aPopulation = 0, bPopulation = 0;
		int aIdx = -1, bIdx = -1, aGroupSize = 0, bGroupSize = 0;
		for (int j = 0; j < n; j++) {
			if ((1 << j) & i) {
				aGroup[j + 1] = true;
				aPopulation += population[j + 1];
				if (aIdx == -1) aIdx = j + 1;
				aGroupSize ++;
			} else {
				bPopulation += population[j + 1];
				if (bIdx == -1) bIdx = j + 1;
				bGroupSize ++;
			}
		}
		int diff = abs(aPopulation - bPopulation);
		if (diff < minimum) {
			if (isConnected(true, aIdx) == aGroupSize && isConnected(false, bIdx) == bGroupSize) {
				minimum = diff;
			}
		}
	}
	if (minimum == INT_MAX) minimum = -1;
	cout << minimum << "\n";
	return 0;
}
```
