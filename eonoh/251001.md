닉네임: eonoh

문제 플랫폼: SWEA

문제 이름 또는 번호: 1767 / 프로세서 연결하기

문제 링크: https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV4suNtaXFEDFAUf

오늘의 메모(선택): dp 느낌으로 차례대로 최솟값을 구해나가면 되는 줄 알았다. 하지만 그런식으로 처리하니까 프로세서를 최대한 많이 연결해야한다는 조건을 충족하지 못했다. 그래서 dfs 로 완탐을 했더니 된다 !

코드(선택): cpp

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
using namespace std;

int n;
int map[12][12];
vector<pair<int, int>> cores;
int maxConnected;
int minWireLength = INT_MAX;

int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };

void init() {
	cores.clear();
	maxConnected = 0;
	minWireLength = INT_MAX;
}

void input() {
	for (int y = 0; y < n; y++) {
		for (int x = 0; x < n; x++) {
			cin >> map[y][x];
			if (map[y][x] == 1) {
				if (y != 00 && x != 0 && y != n - 1 && x != n - 1) {
					cores.push_back({ y, x });
				}
			}
		}
	}
}

bool isPossible(int y, int x, int dir) {
	while (1) {
		y += dy[dir];
		x += dx[dir];
		if (y < 0 || y >= n || x < 0 || x >= n) break;
		if (map[y][x] != 0) return false;
	}
	return true;
}

int setWire(int y, int x, int dir, int value) {
	int len = 0;
	while (1) {
		y += dy[dir];
		x += dx[dir];
		if (y < 0 || y >= n || x < 0 || x >= n) break;
		map[y][x] = value;
		len++;
	}
	return len;
}

void dfs(int idx, int connected, int wireLength) {
	if (idx == cores.size()) {
		if (connected > maxConnected) {
			maxConnected = connected;
			minWireLength = wireLength;
		}
		else if (connected == maxConnected) {
			minWireLength = min(minWireLength, wireLength);
		}
		return;
	}

	int y = cores[idx].first;
	int x = cores[idx].second;

	for (int d = 0; d < 4; d++) {
		if (isPossible(y, x, d)) {
			int len = setWire(y, x, d, 2);
			dfs(idx + 1, connected + 1, wireLength + len);
			setWire(y, x, d, 0);
		}
	}
}

int main() {
	int t;
	cin >> t;

	for (int tc = 1; tc <= t; tc++) {
		cin >> n;
		init();
		input();
		dfs(0, 0, 0);
		cout << "#" << tc << " " << minWireLength << "\n";
	}
	return 0;
}
```
