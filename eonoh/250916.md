닉네임: eonoh

문제 플랫폼: 백준

문제 이름 또는 번호: 2533 / 사회망 서비스(SNS)

문제 링크: https://www.acmicpc.net/problem/2533

오늘의 메모(선택): 가장 아래 노드로 내려가 해당 노드를 선택할 경우와 선택하지 않을 경우를 각각 dp[0], dp[1]에 저장을 해서 루트 노드까지 올라가는 문제였습니다. 트리를 양방향으로 써야하는 경우는 단방향으로 사용할 경우, 아래에서 위로 올라갈 때 탐색이 누락될 수도 있기 때문!

코드(선택): java

```java
import java.io.*;
import java.util.*;

class Main {
	static int n;
	static ArrayList<ArrayList<Integer>> graph;
	static int [][]dp;
	static boolean []visited;

	public static void dfs(int node) {
		visited[node] = true;
		dp[node][0] = 0;
		dp[node][1] = 1;

		for (int x : graph.get(node)) {
			if (!visited[x]) {
				dfs(x);
				dp[node][0] += dp[x][1];
				dp[node][1] += Math.min(dp[x][0], dp[x][1]);
			}
		}
	}

	public static void main(String[] args) throws IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		n = Integer.parseInt(br.readLine());

		graph = new ArrayList<>(n + 1);
		for (int i = 0; i <= n; i++) graph.add(new ArrayList<>());
		dp = new int[n + 1][2];
		visited = new boolean[n + 1];

		for (int i = 0; i < n - 1; i++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int u = Integer.parseInt(st.nextToken());
			int v = Integer.parseInt(st.nextToken());
			graph.get(u).add(v);
			graph.get(v).add(u);
		}
		dfs(1);
		int result = Math.min(dp[1][0], dp[1][1]);
		System.out.println(result);
	}
}
```
