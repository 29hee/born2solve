**닉네임**: kchoo

**문제 플랫폼**: 프로그래머스

**문제 이름 또는 번호**: 미로탈출명령어

**문제 링크**: https://school.programmers.co.kr/learn/courses/30/lessons/150365

**오늘의 메모(선택)**: 

DFS + 가지치기로 사전순 최소 경로 탐색, 홀짝성 불일치 시 impossible

**코드(선택)**: 

```c++
#include <string>
#include <vector>
#include <cstdlib>

using namespace std;

int maxHeight, maxWidth, targetRow, targetCol, maxSteps;
int dx[4] = { 1, 0, 0, -1 };
int dy[4] = { 0, -1, 1, 0 };
char dir[4] = { 'd', 'l', 'r', 'u' };
string path = "";
bool found = false;

bool InBounds(int x, int y) {
    return x > 0 && x <= maxHeight && y > 0 && y <= maxWidth;
}

bool CanReach(int x, int y, int steps) {
    return abs(x - targetRow) + abs(y - targetCol) <= steps;
}

void Search(int x, int y, int steps, string currPath) {
    if (steps == 0 && x == targetRow && y == targetCol) {
        found = true;
        path = currPath;
        return;
    }
    for (int i = 0; i < 4; i++) {
        int nextX = x + dx[i];
        int nextY = y + dy[i];
        if (!InBounds(nextX, nextY) || !CanReach(nextX, nextY, steps - 1)) continue;
        Search(nextX, nextY, steps - 1, currPath + dir[i]);
        if (found) return;
    }
}

string solution(int n, int m, int x, int y, int r, int c, int k) {
    maxHeight = n;
    maxWidth = m;
    targetRow = r;
    targetCol = c;
    maxSteps = k;

    if (!CanReach(x, y, k) || ((abs(x - r) + abs(y - c)) % 2) != (k % 2)) return "impossible";
    Search(x, y, k, "");
    return path;
}
```
