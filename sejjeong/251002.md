**닉네임**: sejjeong

**문제 플랫폼**: 프로그래머스

**문제 이름 또는 번호**: 게임 맵 최단 거리

**문제 링크**: https://school.programmers.co.kr/learn/courses/30/lessons/1844#

**오늘의 메모(선택)**: 
                    단순 BFS, currentDistance > minMaps[y][x] -> currentDistance >= minMaps[y][x]로 변경하니 됨
                    쓸데없는 분기가 많이 줄었을 듯

**코드(선택)**:

C++

```
#include <vector>
#include <limits>
#include <queue>
#include <iostream>
using namespace std;

int solution(vector<vector<int> > maps)
{
    vector<vector<int> > minMaps;
    for (size_t i = 0; i < maps.size(); ++i)
    {
        minMaps.push_back(vector<int>(maps[i].size(), numeric_limits<int>::max()));
    }
    
    queue<int> xs;
    queue<int> ys;
    queue<int> currentDistances;
    
    xs.push(0);
    ys.push(0);
    currentDistances.push(1);
    
    while (xs.empty() == false)
    {
        int x = xs.front();
        int y = ys.front();
        int currentDistance = currentDistances.front();
        if (x == maps[0].size() - 1 && y == maps.size() - 1)
        {
            return currentDistance;
        }
        
        xs.pop();
        ys.pop();
        currentDistances.pop();
        
        if (x < 0 || y < 0 || y >= maps.size() || x >= maps[0].size()
            || maps[y][x] == 0 || currentDistance >= minMaps[y][x])
        {
            continue;
        }
        
        minMaps[y][x] = currentDistance;
        
        xs.push(x + 1);
        ys.push(y);
        currentDistances.push(currentDistance + 1);
        
        xs.push(x - 1);
        ys.push(y);
        currentDistances.push(currentDistance + 1);
        
        xs.push(x);
        ys.push(y + 1);
        currentDistances.push(currentDistance + 1);
        
        xs.push(x);
        ys.push(y - 1);
        currentDistances.push(currentDistance + 1);

        
    }
    
    return -1;
}




```

