**닉네임**: sejjeong

**문제 플랫폼**: 프로그래머스

**문제 이름 또는 번호**: 소수 찾기

**문제 링크**: https://school.programmers.co.kr/learn/courses/30/lessons/42839?language=cpp

**오늘의 메모(선택)**: 
            완전 탐색 -> 순열이 필요하여 작성.
            소수 찾기 -> 로직 작성 도중에 매우 빠른 소수 찾기 알고리듬이 필요하여 에라토스테네스의 체를 공부하여 작성함.
            

**코드(선택)**:

C++

```
#include <string>
#include <vector>
#include <unordered_set>
#include <cstring>
#include <iostream>
#include <cmath>

using namespace std;

void findPermutation(const string& numbers, const size_t depth, bool* bVisitedNumbers, const size_t madeNumber, unordered_set<size_t>& outNumbers, const size_t k);

int solution(string numbers) {
    
    bool* bVisitedNumbers = new bool[numbers.size()];
    unordered_set<size_t> permutationNumbers;
    for (size_t i = 0; i < numbers.size(); ++i)
    {
        memset(bVisitedNumbers, false, numbers.size());
        findPermutation(numbers, 0, bVisitedNumbers, 0, permutationNumbers, i + 1);
    }
    
    delete[] bVisitedNumbers;
    
    size_t maxNumber = 0;
    for (size_t num : permutationNumbers)
    {
        maxNumber = std::max(num, maxNumber);
    }
    
    bool* bPrimeNumbers = new bool[maxNumber + 1];
    memset(bPrimeNumbers, 1, maxNumber + 1);
    
    unordered_set<size_t> primeNumbers;

    for (size_t i = 2; i <= maxNumber; ++i)
    {
        if (bPrimeNumbers[i])
        {
            primeNumbers.insert(i);
            for (size_t j = i * i; j <= maxNumber; j += i)
            {
                bPrimeNumbers[j] = false;
            }
        }
    }
    delete[] bPrimeNumbers;
    
    int answer = 0;
    for (size_t num : permutationNumbers)
    {
        auto it = primeNumbers.find(num);
        if (it != primeNumbers.end())
        {
            ++answer;
        }
    }
    // 만들 수 있는 숫자의 조합을 구하고
    // 제일 큰 애를 기준으로 배열 사이즈를 만든다.
    // 배열 사이즈만큼 소수를 구하고
    // 해시에 집어 넣은 뒤 꺼내서 확인하면 된다.
    return answer;
}

void findPermutation(const string& numbers, const size_t depth, bool* bVisitedNumbers, const size_t madeNumber, unordered_set<size_t>& outNumbers, const size_t k)
{
    if (depth == k)
    {
        outNumbers.insert(madeNumber);
        return;
    }
    
    for (size_t i = 0; i < numbers.size(); ++i)
    {
        if (bVisitedNumbers[i])
        {
            continue;
        }
        bVisitedNumbers[i] = true;
        int result = madeNumber * 10 + (numbers[i] - '0');
        findPermutation(numbers, depth + 1, bVisitedNumbers, result, outNumbers, k);
        bVisitedNumbers[i] = false;
    }
    
}



```