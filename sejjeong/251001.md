**닉네임**: sejjeong

**문제 플랫폼**: 프로그래머스

**문제 이름 또는 번호**: 게임 맵 최단 거리

**문제 링크**: https://school.programmers.co.kr/learn/courses/30/lessons/1844#

**오늘의 메모(선택)**: 
                    단순 BFS, 시간 초과
                    다른 방법 찾아볼 것
            

**코드(선택)**:

C++

```
#include <vector>
#include <limits>
#include <queue>
#include <iostream>
using namespace std;

int solution(vector<vector<int> > maps)
{
    vector<vector<int> > minMaps;
    for (size_t i = 0; i < maps.size(); ++i)
    {
        minMaps.push_back(vector<int>(maps[i].size(), numeric_limits<int>::max()));
    }
    
    queue<int> xs;
    queue<int> ys;
    queue<int> currentDistances;
    
    xs.push(0);
    ys.push(0);
    currentDistances.push(1);
    
    while (xs.empty() == false)
    {
        int x = xs.front();
        int y = ys.front();
        int currentDistance = currentDistances.front();
        
        xs.pop();
        ys.pop();
        currentDistances.pop();
        
        int minDistance = minMaps[maps.size() - 1][maps[0].size() - 1];
        if (x < 0 || y < 0 || y >= maps.size() || x >= maps[0].size()
            || maps[y][x] == 0 || currentDistance > minMaps[y][x] || currentDistance > minDistance)
        {
            continue;
        }
        minMaps[y][x] = min(minMaps[y][x], currentDistance);
        
        xs.push(x + 1);
        ys.push(y);
        
        xs.push(x);
        ys.push(y + 1);
        
        if (x - 1 >= 0)
        {
            xs.push(x - 1);
            ys.push(y);
            currentDistances.push(currentDistance + 1);
        }
        
        if (y - 1 >= 0)
        {
            xs.push(x);
            ys.push(y - 1);
            currentDistances.push(currentDistance + 1);
        }
        
        currentDistances.push(currentDistance + 1);
        currentDistances.push(currentDistance + 1);
    }
    
    int minDistance = minMaps[maps.size() - 1][maps[0].size() - 1];
    return minDistance == numeric_limits<int>::max() ? -1 : minDistance;
}




```

