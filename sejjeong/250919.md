**닉네임**: sejjeong

**문제 플랫폼**: 프로그래머스

**문제 이름 또는 번호**: 네트워크

**문제 링크**: https://school.programmers.co.kr/learn/courses/30/lessons/43162

**오늘의 메모(선택)**: 
            그래프
            처음 코드와 개선 코드가 있음, 중복 순회를 없애서 매우 빨라짐

**코드(선택)**:

C++

```

// 처음 코드

#include <string>
#include <vector>
#include <set>
#include <algorithm>
#include <queue>
#include <iostream>

using namespace std;

int solution(int n, vector<vector<int>> computers) {

    set<vector<int> > networks;
    for (int i = 0; i < computers.size(); ++i)
    {
        set<int> discoverdNode;
        vector<int> network;

        queue<int> que;

        discoverdNode.insert(i);
        que.push(i);

        while (que.size() != 0)
        {
            int node = que.front();
            network.push_back(node);
            que.pop();

            for (int j = 0; j < computers.size(); ++j)
            {
                if (i == j)
                {
                    continue;
                }
                if (computers[node][j] == 1)
                {
                    if (discoverdNode.find(j) == discoverdNode.end())
                    {
                        discoverdNode.insert(j);
                        que.push(j);
                    }
                }
            }
        }

        sort(network.begin(), network.end());
        networks.insert(network);
    }

    return static_cast<int>(networks.size());
}




// 개선 코드

#include <string>
#include <vector>
#include <unordered_set>
#include <queue>

using namespace std;

int solution(int n, vector<vector<int>> computers) {

    int answer = 0;
    unordered_set<int> discoverdNode; 
    for (int i = 0; i < computers.size(); ++i)
    {
        if (discoverdNode.find(i) != discoverdNode.end())
        {
            continue;
        }

        queue<int> que;

        discoverdNode.insert(i);
        que.push(i);

        while (que.size() != 0)
        {
            int node = que.front();
            que.pop();

            for (int j = 0; j < computers.size(); ++j)
            {
                if (i == j)
                {
                    continue;
                }
                if (computers[node][j] == 1 && discoverdNode.find(j) == discoverdNode.end())
                {
                    discoverdNode.insert(j);
                    que.push(j);
                }
            }
        }
        ++answer;
    }

    return answer;
}


```